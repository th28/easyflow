import tkinter as tk
import ast
import gurobipy as gp
from math import sin, cos, atan2
from gurobipy import GRB


def solver(directed_graph):
    """Solves a simple single commoditiy network-flow problem using the data from the user specified graph. Basically
    just a simplified version of the netflow.py example from the gurobi documentation. """

    nodes, generated_flow = gp.multidict(directed_graph.nodes)

    print(nodes)
    print(generated_flow)

    edges, capacity, cost = gp.multidict(directed_graph.edges)

    print(edges)
    print(capacity)
    print(cost)

    model = gp.Model('network_flow')
    flow = model.addVars(edges, lb=0, obj=cost, name="flow")

    # Flow capacity constraints
    model.addConstrs(flow[i, j] <= capacity[i, j] for i, j in edges)
    # Flow balance constraints, basically: flow generated by node + input flow to node = output flow from node
    model.addConstrs(generated_flow[j] + flow.sum('*', j) == flow.sum(j, '*') for j in nodes)

    model.optimize()


def get_clicked_id(event):
    """Return id of clicked canvas item"""
    clicked_id = event.widget.find_withtag("current")[0]
    return clicked_id


def get_clicked_tag(event, clicked_id):
    """Return tag of clicked canvas item"""
    clicked_tag = event.widget.gettags(clicked_id)[0]
    return clicked_tag


def get_label_offset(x1, y1, x2, y2, change):
    """Offset edge labels so they don't appear on the edge itself and remain readible"""
    max_change = max(abs(x1 - x2), abs(y1 - y2))
    offset = [0, 0]
    if max_change == abs(x1 - x2):
        offset[1] = change
        return offset
    else:
        offset[0] = change
        return offset


def get_circle_intersection(x1, y1, x2, y2, r):
    """Do some geometry to get nice looking node connections"""

    theta = atan2(y1 - y2, x1 - x2)
    x_inter = x2 + r * cos(theta)
    y_inter = y2 + r * sin(theta)

    return x_inter, y_inter


class GraphCanvas(tk.Canvas):
    """Canvas to draw graphs on. The design here got a bit crazy. Likely could be refactored into Node, Edge etc.
    classes maybe. TODO: REFACTORING(!) There is a lot of global state here. But tkinter does make things a bit
    awkward. Also there is no native tkinter system for properly handling drawing order. Currently using a hack with
    inserting canvas.lift where ever needed. """

    def __init__(self, window, width, height, background, graph_model):
        super().__init__(window, width=width, height=height, background=background)
        self.node_count = 0
        self.is_hovering_item = None
        self.click_number = 0
        self.first_click = []
        self.id_to_node = {}
        self.id_to_edge = {}
        self.item_id_to_text = {}
        self.graph_model = graph_model
        self.click_number = 0
        self.start_x, self.start_y = (0, 0)
        self.start_node = None
        self.end_node = None
        self.clicked_id = None
        self.clicked_tag = None
        self.entry = None
        self.button_solve = tk.Button(self, text="Solve", command=self.solve, anchor=tk.W)
        self.button_solve_window = self.create_window(10, 10, anchor=tk.NW, window=self.button_solve)
        self.node_size = 15
        self.guide = None

    def solve(self):
        solver(self.graph_model)

    def submit_edit(self, event):
        """Changes the underlying graph data structure and destroys the used edit dialog"""
        if self.clicked_tag == "node":
            node_to_update = self.id_to_node[self.clicked_id]
            text_id = self.item_id_to_text[self.clicked_id]
            self.itemconfig(text_id, text=self.entry.get())
            self.graph_model.nodes[node_to_update] = float(self.entry.get())
        else:
            edge_to_update = self.id_to_edge[self.clicked_id]
            text_id = self.item_id_to_text[self.clicked_id]
            self.itemconfig(text_id, text=self.entry.get())
            self.lift("text")
            input_tuple = ast.literal_eval(self.entry.get())
            self.graph_model.edges[edge_to_update] = [input_tuple[0], input_tuple[1]]
            print(self.graph_model.edges)
        self.entry.destroy()

    def create_edit(self, event):
        """"Opens a dialog to edit an edge weight or node value"""
        if self.is_hovering_item is not None:
            self.entry = tk.Entry(master=self, width=5, background='blue', foreground='white')
            self.entry.place(x=event.x, y=event.y)
            self.clicked_id = get_clicked_id(event)
            self.clicked_tag = get_clicked_tag(event, self.clicked_id)
            self.click_number = 0
            self.entry.bind('<Return>', self.submit_edit)

    def create_circle(self, x, y, r, canvas):
        """Utility method to draw circles where the user clicks and not based on bounding box"""

        text_id = canvas.create_text(x, y, text="", state=tk.DISABLED, tags="text")
        circle_id = canvas.create_oval(x - r, y - r, x + r, y + r, activefill='blue', tags="node", fill='white')

        self.lift("node")
        self.lift("text")

        self.item_id_to_text[circle_id] = text_id
        return circle_id

    def add_node(self, event):
        """Adds a node to the ui as well as underlying graph data structure"""
        node_id = self.create_circle(event.x, event.y, self.node_size, self)
        self.node_count += 1
        self.graph_model.add_node(self.node_count, 0)
        self.id_to_node[node_id] = self.node_count

    def reset_guide(self):
        self.delete(self.guide)
        self.guide = None

    def draw_guide(self, event):

        if self.click_number == 1 and self.guide is None:
            self.guide = self.create_line(self.start_x, self.start_y, event.x, event.y, arrow=tk.LAST)
            self.lift("node")
            self.lift("text")
        elif self.click_number == 1 and self.guide is not None:
            self.coords(self.guide, self.start_x, self.start_y, event.x, event.y)

    def draw_line(self, event):
        """Draws an arrow between two nodes based on sequence of user clicks. """
        if self.is_hovering_item == "node":
            if self.click_number == 0:
                clicked_node_coords = self.coords(get_clicked_id(event))
                self.start_x, self.start_y = (clicked_node_coords[0] + self.node_size,
                                              clicked_node_coords[1] + self.node_size)
                self.click_number = 1
                self.start_node = self.id_to_node[get_clicked_id(event)]
            else:
                clicked_node_coords = self.coords(get_clicked_id(event))
                end_x, end_y = (clicked_node_coords[0] + self.node_size,
                                clicked_node_coords[1] + self.node_size)
                x1, y1 = (self.start_x, self.start_y)
                intersect_coords = get_circle_intersection(x1, y1, end_x, end_y, self.node_size)
                x2, y2 = (intersect_coords[0], intersect_coords[1])
                self.reset_guide()
                edge_id = self.create_line(x1, y1, x2, y2, activefill='red', arrow=tk.LAST, width=4, tags="edge")
                self.lift("node")
                self.lift("text")
                self.end_node = self.id_to_node[get_clicked_id(event)]

                self.graph_model.add_edge(self.start_node, self.end_node, 0, 0)
                offset = get_label_offset(x1, y1, x2, y2, 20)
                text_id = self.create_text(offset[0] + (x1 + x2) / 2, offset[1] + (y1 + y2) / 2,
                                           text="",
                                           state=tk.DISABLED)

                self.id_to_edge[edge_id] = (self.start_node, self.end_node)
                self.item_id_to_text[edge_id] = text_id
                self.click_number = 0

    def update_hover_item(self, event):
        if str(event.type) == 'Enter':
            hover_id = event.widget.find_withtag("current")[0]
            hover_tag = event.widget.gettags(hover_id)[0]
            self.is_hovering_item = hover_tag
            print(self.is_hovering_item)
        if str(event.type) == 'Leave':
            self.is_hovering_item = None